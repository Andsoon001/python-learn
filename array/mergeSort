归并排序（Merge Sort）是一种有效的排序算法，采用了分治法（Divide and Conquer）的思想。它将一个大问题分解为多个小问题，递归地解决这些子问题，然后将结果合并成最终的答案。归并排序的时间复杂度是 O(n log n)，它是一种稳定的排序算法，特别适合处理大规模数据集。

### 归并排序的基本步骤

归并排序的核心思想是“分而治之”，具体步骤可以总结为以下几步：

1. **分解**：将原始数组从中间拆分成两个子数组，直到子数组的大小为 1。

2. **递归排序**：对子数组进行递归排序（此时数组大小为 1，认为它们已经排序）。

3. **合并**：将已经排序的子数组合并成一个新的有序数组。

```Python
class Solution:
    # 合并过程
    def merge(self, left_nums: [int], right_nums: [int]):
        nums = []
        left_i, right_i = 0, 0
        while left_i < len(left_nums) and right_i < len(right_nums):
            # 将两个有序子数组中较小元素依次插入到结果数组中
            if left_nums[left_i] < right_nums[right_i]:
                nums.append(left_nums[left_i])
                left_i += 1
            else:
                nums.append(right_nums[right_i])
                right_i += 1
        
        # 如果左子数组有剩余元素，则将其插入到结果数组中
        while left_i < len(left_nums):
            nums.append(left_nums[left_i])
            left_i += 1
        
        # 如果右子数组有剩余元素，则将其插入到结果数组中
        while right_i < len(right_nums):
            nums.append(right_nums[right_i])
            right_i += 1
        
        # 返回合并后的结果数组
        return nums

    # 分解过程
    def mergeSort(self, nums: [int]) -> [int]:
        # 数组元素个数小于等于 1 时，直接返回原数组
        if len(nums) <= 1:
            return nums
        
        mid = len(nums) // 2                        # 将数组从中间位置分为左右两个数组
        left_nums = self.mergeSort(nums[0: mid])    # 递归将左子数组进行分解和排序
        right_nums =  self.mergeSort(nums[mid:])    # 递归将右子数组进行分解和排序
        return self.merge(left_nums, right_nums)    # 把当前数组组中有序子数组逐层向上，进行两两合并

    def sortArray(self, nums: [int]) -> [int]:
        return self.mergeSort(nums)
# 创建一个 Solution 对象
#创建 Solution 类的一个实例。
solution = Solution()

# 输入待排序的数组
nums = [7,2,6,8,0,4,1,5,9,3]

# 调用 sortArray 方法，得到排序后的数组
sorted_nums = solution.sortArray(nums)

# 输出排序结果
print(sorted_nums)
```


## 代码解析

### 函数定义：

```Python
def mergeSort(self, nums: [int]) -> [int]:
```


- 定义了一个递归函数 `mergeSort`，输入参数为一个数组 `nums`，返回值是排序后的数组。

---

### 边界条件：

```Python
if len(nums) <= 1:
    return nums
```


- **作用**：

  - 如果数组长度小于等于 1，则认为数组已经是有序的，直接返回该数组。

- **原因**：

  - 归并排序的终止条件是无法继续分解数组（即数组的长度为 1 或 0）。

例如：

```Python
nums = [3]  # 长度为1，直接返回 [3]
```


---

### 分解数组：

```Python
mid = len(nums) // 2
left_nums = self.mergeSort(nums[0: mid])
right_nums = self.mergeSort(nums[mid:])
```


- **`mid = len(nums) // 2`**:

  - 计算数组的中间位置，将数组分成两个部分：

    - 左半部分：`nums[0: mid]`

    - 右半部分：`nums[mid:]`

- **递归调用**：

  - 对左半部分调用 `mergeSort`，得到排序后的左子数组 `left_nums`。

  - 对右半部分调用 `mergeSort`，得到排序后的右子数组 `right_nums`。

- **分解过程的本质**：

  - 通过递归，将一个大数组不断分成更小的子数组，直到每个子数组只有一个元素。

例如：

```Python
nums = [5, 2, 3, 1]
# 第一次分解：mid = 2，left_nums = [5, 2]，right_nums = [3, 1]
# 第二次分解：left_nums 分解为 [5] 和 [2]；right_nums 分解为 [3] 和 [1]
```


---

### 合并数组：

```Python
return self.merge(left_nums, right_nums)
```


- **调用合并函数**：

  - 将**已经排序**的左右两个子数组 `left_nums` 和 `right_nums` 传递给 `merge` 函数，得到合并后的有序数组。

- **关键逻辑**：

  - `merge` 函数通过比较 `left_nums` 和 `right_nums` 中的元素大小，将两个子数组按顺序合并为一个更大的有序数组。

例如：

```Python
# 左右子数组已经分别排序：
left_nums = [2, 5], right_nums = [1, 3]
# 合并后的结果为 [1, 2, 3, 5]
```


---

### 完整示例解析：

以输入数组 `nums = [5, 2, 3, 1]` 为例，运行过程如下：

4. 初始调用：

  - `mergeSort([5, 2, 3, 1])`

  - 分解为 `mergeSort([5, 2])` 和 `mergeSort([3, 1])`

5. 处理左半部分 `mergeSort([5, 2])`：

  - 分解为 `mergeSort([5])` 和 `mergeSort([2])`

  - `merge([5], [2])` 得到 `[2, 5]`

6. 处理右半部分 `mergeSort([3, 1])`：

  - 分解为 `mergeSort([3])` 和 `mergeSort([1])`

  - `merge([3], [1])` 得到 `[1, 3]`

7. 合并左右部分：

  - `merge([2, 5], [1, 3])` 得到最终排序结果 `[1, 2, 3, 5]`

---

### 总结：

- `mergeSort` 的核心是 **递归分解 + 合并排序**。

- 递归部分负责将问题逐步缩小，直到可以直接解决。

- 合并部分将分解的小问题逐步合并为完整的解决方案。

- 整个过程按照**二叉树的结构**展开，最终在合并阶段完成排序。



在归并排序中，**“已经排序”** 是指递归调用过程中，左右子数组经过递归处理后，保证了其内部元素是按照升序排列的。

### 1. 递归特性保证排序

归并排序的分治过程分为两步：

- **分解**：将一个数组递归拆分为更小的子数组，直到每个子数组的长度为 1。

- **合并**：在每次递归返回时，使用 `merge` 函数合并两个**已经排序的子数组**。

对于一个长度为 1 的数组，它天然是“已经排序”的，因为只有一个元素，不需要排序。

---

### 2. 为什么左右子数组是“已经排序”的？

#### 第一次合并：

当递归到最底层时，每个子数组长度为 1，递归停止，然后开始合并。因为单个元素是天然有序的，直接传递给 `merge` 函数：

```Python
nums = [5, 2]
# 递归拆分为：
left_nums = [5]  # 单个元素，已排序
right_nums = [2]  # 单个元素，已排序
# 合并：
merge([5], [2]) -> [2, 5]
```


#### 第二次合并：

当返回上一层时，合并后的子数组（如 `[2, 5]`）已经排序，再与另一侧递归返回的子数组进行合并：

```Python
nums = [5, 2, 3, 1]
# 第一次递归合并结果：
left_nums = [2, 5]  # 已排序
right_nums = [1, 3]  # 已排序
# 合并：
merge([2, 5], [1, 3]) -> [1, 2, 3, 5]
```


递归逐层向上，每次合并后的数组都是有序的，因此传递给 `merge` 的左右子数组是“已经排序”的。

---

### 3. 合并排序的关键逻辑：

在 `merge` 函数中，由于输入的两个数组是“已经排序”的，合并过程可以通过比较首元素的大小轻松完成：

- 比较 `left_nums` 和 `right_nums` 的当前首元素，将较小的元素添加到结果数组。

- 保证了合并后的数组仍然是有序的。

---

### 4. 代码运行过程可视化

以数组 `[5, 2, 3, 1]` 为例，运行过程如下：

8. 初始调用 `mergeSort([5, 2, 3, 1])`：

  - 拆分为 `mergeSort([5, 2])` 和 `mergeSort([3, 1])`

9. 处理左半部分：

  - `mergeSort([5, 2])` 拆分为 `mergeSort([5])` 和 `mergeSort([2])`

  - 合并后：`merge([5], [2]) -> [2, 5]`（已排序）

10. 处理右半部分：

  - `mergeSort([3, 1])` 拆分为 `mergeSort([3])` 和 `mergeSort([1])`

  - 合并后：`merge([3], [1]) -> [1, 3]`（已排序）

11. 合并左右部分：

  - 合并 `[2, 5]` 和 `[1, 3]`：

    - `merge([2, 5], [1, 3]) -> [1, 2, 3, 5]`

此时，每次传递给 `merge` 的左右子数组（如 `[2, 5]` 和 `[1, 3]`）都是“已经排序”的。

---

### 总结

“已经排序”是递归的归并排序过程中的一个前提条件。这一条件由递归分解的最底层开始逐步保证，每次合并后生成的数组都是有序的，从而递归向上传递时，合并的子数组也是有序的。



## 个人认为关键是要理解其中的**递归**和**分解**



怎样理解在mergesort中调用self.mergesort？

在 `mergeSort` 函数中调用 `self.mergeSort` 是 **递归调用** 的体现，这种调用方式是归并排序的核心思想。为了帮助你更好地理解这一点，我们从递归的原理和实际运行过程来分析。

---

### 1. 什么是递归调用？

递归调用是指一个函数在其自身的定义或实现中调用了自己。在归并排序中，递归调用的目的是 **分解问题**，将一个大问题逐步分解为多个小问题，直到可以直接解决（即达到递归的终止条件）。

在 `mergeSort` 中，`self.mergeSort(nums)` 会将数组不断分成两半，分别对左右子数组再次调用 `mergeSort`，这是归并排序“分治法”的核心：

- **分解**：递归调用将数组拆分为更小的子问题。

- **解决**：递归到底层时，子数组长度为 1，被认为是已排序的。

- **合并**：递归返回时，将子数组通过 `merge` 合并成更大的有序数组。

---

### 2. `self.mergeSort` 在归并排序中的作用

归并排序中，调用 `self.mergeSort` 是为了对左、右子数组分别进行排序，递归调用保证了：

- 当递归调用完成返回时，左右子数组已经是有序的。

- 然后通过 `merge` 函数将两部分合并成一个更大的有序数组。

例如，假设我们要排序数组 `[5, 2, 3, 1]`：

#### 初始调用：

```Python
mergeSort([5, 2, 3, 1])
```


#### 第一次递归调用：

```Python
mid = 2
left_nums = self.mergeSort([5, 2])  # 递归处理左半部分
right_nums = self.mergeSort([3, 1])  # 递归处理右半部分
```


#### 继续递归处理左半部分 `[5, 2]`：

```Python
self.mergeSort([5]) -> [5]  # 长度为1，直接返回
self.mergeSort([2]) -> [2]  # 长度为1，直接返回
merge([5], [2]) -> [2, 5]
```


递归返回后，左半部分 `[5, 2]` 被处理成 `[2, 5]`。

#### 递归处理右半部分 `[3, 1]`：

```Python
self.mergeSort([3]) -> [3]  # 长度为1，直接返回
self.mergeSort([1]) -> [1]  # 长度为1，直接返回
merge([3], [1]) -> [1, 3]
```


递归返回后，右半部分 `[3, 1]` 被处理成 `[1, 3]`。

#### 合并左右部分：

```Python
merge([2, 5], [1, 3]) -> [1, 2, 3, 5]
```


最终得到完整的排序结果。

---

### 3. 递归调用的关键点

#### (1) **递归拆分：分解成子问题**

每次调用 `self.mergeSort`，数组都会被分成两部分，直到长度为 1：

```Python
nums = [5, 2, 3, 1]
# 第一次拆分：[5, 2], [3, 1]
# 第二次拆分：[5], [2], [3], [1]
```


#### (2) **递归的终止条件**

在 `mergeSort` 函数的开头，有一个条件控制递归停止：

```Python
if len(nums) <= 1:
    return nums
```


当数组长度小于或等于 1 时，直接返回该数组，因为此时它已经是有序的。

#### (3) **递归的回归：合并结果**

在递归返回的过程中，`mergeSort` 将递归返回的左右子数组逐步通过 `merge` 合并，直到最终返回完整排序结果。

---

### 4. 递归调用的结构示意图

假设数组为 `[5, 2, 3, 1]`，递归过程可以用一个树状结构表示：

```Python
mergeSort([5, 2, 3, 1])
    ├── mergeSort([5, 2])
    │       ├── mergeSort([5]) -> [5]
    │       ├── mergeSort([2]) -> [2]
    │       └── merge([5], [2]) -> [2, 5]
    ├── mergeSort([3, 1])
    │       ├── mergeSort([3]) -> [3]
    │       ├── mergeSort([1]) -> [1]
    │       └── merge([3], [1]) -> [1, 3]
    └── merge([2, 5], [1, 3]) -> [1, 2, 3, 5]
```


从上到下是递归拆分的过程，从下到上是递归返回并合并的过程。

---

### 5. 总结

- 在 `mergeSort` 中调用 `self.mergeSort` 是递归的核心，通过递归将问题逐步分解成更小的子问题。

- 递归拆分过程保证了子数组长度不断减小，最终到长度为 1 时停止递归。

- 递归返回时，通过合并操作逐步解决更大的问题，最终完成排序。

- **递归的两个关键要素**：

  1. **终止条件**：数组长度为 1 时停止递归。

  2. **子问题解决**：递归调用 `self.mergeSort` 对左右部分排序，再合merge它们。









接下来以[7, 2, 6, 8, 0, 4, 1, 5, 9, 3]为例

```Python
mergeSort([7, 2, 6, 8, 0, 4, 1, 5, 9, 3])
    ├── mergeSort([7, 2, 6, 8, 0])           # 分割左半部分
    │       ├── mergeSort([7, 2])               # 继续分割
    │       │       ├── mergeSort([7]) -> [7]    # 单个元素，直接返回
    │       │       ├── mergeSort([2]) -> [2]    # 单个元素，直接返回
    │       │       └── merge([7], [2]) -> [2, 7] # 合并 [7] 和 [2]
    │       ├── mergeSort([6, 8, 0])             # 继续分割
    │       │       ├── mergeSort([6]) -> [6]    # 单个元素，直接返回
    │       │       ├── mergeSort([8, 0])         # 继续分割
    │       │       │       ├── mergeSort([8]) -> [8]  # 单个元素，直接返回
    │       │       │       ├── mergeSort([0]) -> [0]  # 单个元素，直接返回
    │       │       │       └── merge([8], [0]) -> [0, 8] # 合并 [8] 和 [0]
    │       │       └── merge([6], [0, 8]) -> [0, 6, 8] # 合并 [6] 和 [0, 8]
    │       └── merge([2, 7], [0, 6, 8]) -> [0, 2, 6, 7, 8] # 合并 [2, 7] 和 [0, 6, 8]
    ├── mergeSort([4, 1, 5, 9, 3])           # 分割右半部分
    │       ├── mergeSort([4, 1])               # 继续分割
    │       │       ├── mergeSort([4]) -> [4]    # 单个元素，直接返回
    │       │       ├── mergeSort([1]) -> [1]    # 单个元素，直接返回
    │       │       └── merge([4], [1]) -> [1, 4] # 合并 [4] 和 [1]
    │       ├── mergeSort([5, 9, 3])             # 继续分割
    │       │       ├── mergeSort([5]) -> [5]    # 单个元素，直接返回
    │       │       ├── mergeSort([9, 3])         # 继续分割
    │       │       │       ├── mergeSort([9]) -> [9]  # 单个元素，直接返回
    │       │       │       ├── mergeSort([3]) -> [3]  # 单个元素，直接返回
    │       │       │       └── merge([9], [3]) -> [3, 9] # 合并 [9] 和 [3]
    │       │       └── merge([5], [3, 9]) -> [3, 5, 9] # 合并 [5] 和 [3, 9]
    │       └── merge([1, 4], [3, 5, 9]) -> [1, 3, 4, 5, 9] # 合并 [1, 4] 和 [3, 5, 9]
    └── merge([0, 2, 6, 7, 8], [1, 3, 4, 5, 9]) -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # 合并最终两部分
 
```


